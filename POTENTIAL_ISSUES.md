# 20 потенциальных проблем с обновлением результатов тестов

## Проблемы с сохранением в БД

1. **Не обновляется `updated_at` при UPDATE** - в коде обновления (строка 636-641) не устанавливается `updated_at`, поэтому сортировка по `created_at` может показывать старые записи первыми

2. **Множественные записи для одного теста** - если при первом сохранении произошла ошибка и создалась дублирующая запись, при обновлении обновляется только одна (по `existingResult.id`), а при загрузке могут вернуться обе

3. **Проблема с `.single()` при поиске существующей записи** - если есть несколько записей с одинаковым `test_type` и `session_id`, `.single()` выбросит ошибку вместо возврата первой записи

4. **Несоответствие `test_type`** - при сохранении используется `config.id`, но если в БД уже есть запись с другим форматом `test_type` (например, старое название), обновление не найдет существующую запись и создаст дубликат

5. **Проблема с форматом `answers`** - если старая запись содержит `answers` как строку, а новая как объект (или наоборот), при обновлении формат может не совпадать с ожидаемым на фронтенде

## Проблемы с загрузкой из БД

6. **Сортировка по `created_at` вместо `updated_at`** - при загрузке используется `.order('created_at', { ascending: false })`, что означает, что старые записи (с более поздним `created_at`) будут первыми, даже если они не обновлялись

7. **Отсутствие фильтрации по `updated_at`** - нет фильтрации, чтобы показывать только последние обновленные записи

8. **Загрузка всех записей без дедупликации** - если есть несколько записей для одного теста, загружаются все, и фронтенд должен выбирать последнюю, что может не работать корректно

9. **Проблема с кэшированием на уровне Supabase** - Supabase может кэшировать результаты запросов, и новые данные не сразу доступны

10. **Проблема с транзакциями** - если UPDATE не завершился полностью (например, из-за сетевой ошибки), запись может остаться в промежуточном состоянии

## Проблемы с сопоставлением результатов на фронтенде

11. **Несоответствие `test_type` и `config.id`** - `result.test_type` из БД может не совпадать с `config.id` при вызове `getTestConfig(result.test_type)`, если в БД сохранено старое значение

12. **Проблема с поиском теста в `recommendedTests`** - поиск по URL может не сработать, если URL изменился или не совпадает точно

13. **Проблема с `test.id` vs `testConfigId`** - используется `test.id` для сохранения в `resultsMap`, но `test.id` может не совпадать с `config.id`, что приводит к неправильному сопоставлению

14. **Множественные результаты для одного теста** - если в БД несколько записей, `forEach` обработает все, и последняя перезапишет предыдущую в `resultsMap`, но может быть выбрана не та

15. **Проблема с форматом `answers` при парсинге** - если `result.answers` это строка, но парсинг не удается, используется пустой объект `{}`, что приводит к отсутствию результатов

## Проблемы с состоянием React

16. **Кэширование в состоянии React** - `testResults` может не обновляться, если `setTestResults` вызывается с тем же объектом (по ссылке), React не обнаружит изменения

17. **Проблема с очисткой перед установкой** - `setTestResults({})` с последующим `setTimeout(() => setTestResults(resultsMap), 50)` может не сработать, если компонент перерендерится между вызовами

18. **Проблема с зависимостями `useEffect`** - `useEffect` для загрузки результатов может не сработать, если зависимости не изменились, даже если данные в БД обновились

19. **Проблема с timing** - `fetchAdditionalTestResults` может вызываться до того, как `recommendedTests` загружены, и результаты не будут сопоставлены

20. **Проблема с `refresh` параметром** - проверка `searchParams.get('refresh')` может происходить до того, как `searchParams` обновился после навигации

## Дополнительные проблемы

21. **Проблема с localStorage флагом** - флаг `test_results_updated` может быть установлен, но проверка происходит слишком рано или слишком поздно

22. **Проблема с навигацией** - при переходе с `refresh=true` параметр может быть удален из URL до того, как проверка произошла

23. **Проблема с асинхронностью** - `fetchAdditionalTestResults` асинхронная, но может вызываться несколько раз одновременно, что приводит к race condition

24. **Проблема с форматом данных в БД** - JSONB поле `answers` может храниться в разных форматах (объект vs строка), что приводит к проблемам при парсинге

25. **Проблема с RLS (Row Level Security)** - если в Supabase включен RLS, обновление может не сработать из-за политик безопасности

